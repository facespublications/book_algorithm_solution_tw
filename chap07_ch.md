# 7.1

首先，將數列 `a[0]`, `a[1]`, ..., `a[N-1]` 和數列 `b[0]`, `b[1]`, ..., `b[N-1]` 分別按照小到大的順序排列（稱為排序）。像這樣藉由將數列重新依小到大的順序排列，通常可以使問題更容易思考。另外， N 個元素的排序，可以由 O(N log N) 的計算複雜度得出（參考第 12 章）。

在此，讓我們思考對於數列 `b[0]`, `b[1]`, ..., `b[N-1]` 的這個順序，能夠與數列 `a[0]`, `a[1]`, ..., `a[N-1]` 的哪個元素進行配對。首先，對 `b[0]`，如果不存在可使 `a[i] < b[0]` 的 `a[i]` 時， `b[0]` 無法進行配對。當存在 `a[i]`時，可以將例如 `a[0]` 和 `b[0]` 進行配對（滿足 `a[i] < b[0]` 的任何 `a[i]`都可以進行配對）。

そのことを示してみましょう。`b[0]` を `a[0]` とペアにしないような最適解があったとします。このとき、この解を悪化させることなく (マッチングペアの個数を減らすことなく)、ペアを組み替えることで `b[0]` と `a[0]` が組む解へと変形できることを示します。まず、最適解において
來試著證明這一點吧。假設有一個最佳解，其中 `b[0]` 與 `a[0]` 沒有配對。此時，證明在此解答不惡化（即不減少配對數量）的情況下，可以透過重新排列配對，使`b[0]`和`a[0]`形成一對。首先，設在最佳解中，各自組成下列組合（如果 `a[0]` 或 `b[0]` 任一沒有與其他元素進行配對，只需將其重新連結以組成配對即可）。

- `a[i]` 和 `b[0]`
- `a[0]` 和 `b[j]`

此時，可以重新組成以下配對。

- `a[0] 和 b[0]`
- `a[i]` 和 `b[j]`

這是因為 `a[0] <= a[i] < b[0]` 以及 `a[i] < b[0] <= b[j]` 成立。

根據上述，證明了存在使 `a[0]` 和 `b[0]` 配對的最佳解，因此可以思考將它們排除。對於剩餘的值，也反覆進行同樣手續即可。

總結來說，可以按照以下的方法解決這個問題。計算複雜度為 O(N log N)。

-----

令 i = 0 

對各 j = 0, 1, ..., N-1 

- 如果 `a[i] < b[j]`，則將 `a[i]` 和 `b[j]` 進行配對，並使 `i += 1`
- 否則就略過（`b[j]` 不與任何元素組成'配對）

-----

　

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int main() {
    // 輸入
    int N;
    cin >> N;
    vector<int> A(N), B(N);
    for (int i = 0; i < N; ++i) cin >> A[i];
    for (int i = 0; i < N; ++i) cin >> B[i];

    // 分別排序
    sort(A.begin(), A.end());
    sort(B.begin(), B.end());

    // 依序檢查 B
    int i = 0;
    for (int j = 0; j < N; ++j) {
        if (A[i] < B[j]) ++i;
    }

    // i 為答案
    cout << i << endl;
}
```

　

# 7.2 (ARC 092 C - 2D Plane 2N Points)

問題 7.1是將在一維直線上的點彼此組成配對的問題，而本問題是將在二維平面上的點彼此組成配對的問題。雖然難度有所提高，但通過仔細的考察，仍然能夠解決這個問題。有關具體的演算法，記於以下文章。

[AtCoder ARC 092 C - 2D Plane 2N Point](https://drken1215.hatenablog.com/entry/2021/07/05/183800)

　

# 7.3 (ABC 131 D - Megalomania)

這是在現實社會中也經常出現的問題。像多數人直覺認為的一樣，「從最早截止日期的工作開始處理」是最佳的方法。有關具體的演算法，記於以下文章。

[AtCoder ABC 131 D - Megalomania](https://drken1215.hatenablog.com/entry/2019/06/22/224800)



