# 9.1 (以鏈結串列形成堆疊、佇列)

使用雙向鏈結串列吧。著眼於雙向串列的 head 和 tail。藉由在 head 或 tail 添加元素，及刪除 head 的元素，來實現堆疊和佇列的功能。

具體而言，可以按照下表的方式進行。這些操作都可以用 O(1) 的計算複雜度實現。

　

| 資料結構 |  推入（push）元素 v | 彈出（pop）  |
| ---------- | -------------- | ----------- |
| 堆疊   | 添加到 head     | 刪除 head  |
| 佇列    | 添加到 tail     | 刪除 head  |


　

# 9.2 (逆波蘭表示法)

`(3 + 4) * (1 - 2)` 

上述式子在逆波蘭表示法中，可以表示如下。

```
3 4 + 1 2 - *
```

這可以使用堆疊並如下表所示來計算。

　

| 途中過程        | 堆疊狀態      | 備註                                                         |
| --------------- | ------------ | ------------------------------------------------------------ |
| `3`             | [3]          | 將數值插入堆疊的末尾                                       |
| `3 4`           | [3, 4]       | 將數值插入堆疊的末尾                                       |
| `3 4 +`         | [7]          | 取出堆疊末尾的兩個元素進行運算，將結果插入堆疊的末尾         |
| `3 4 + 1`       | [7, 1]       | 將數值插入堆疊的末尾                                       |
| `3 4 + 1 2`     | [7, 1, 2]    | 將數值插入堆疊的末尾                                       |
| `3 4 + 1 2 -`   | [7, -1]      | 取出堆疊末尾的兩個元素進行運算，將結果插入堆疊的末尾         |
| `3 4 + 1 2 - *` | [-7]         | 最後剩下的值即為答案                                      |

　

具體可以實作如下。令符號的個數為 N，計算複雜度為 O(N)。

　

```cpp
#include <iostream>
#include <stack>
#include <string>
using namespace std;

// 計算以逆波蘭表示法記錄的值
double calc(const string &exp) {
    stack<double> st;
    for (auto c: exp) {
        if (c >= '0' && c <= '9') {
            // 將如 '7' 般的原始文字轉換成 7 這樣的數值
            double add = c - '0';
            st.push(add);
        } else {
            // 運算子時，執行運算
            double a = st.top();
            st.pop();
            double b = st.top();
            st.pop();

            // 將運算的執行結果堆積到堆疊中
            if (c == '+') st.push(b + a);
            else if (c == '-') st.push(b - a);
            else if (c == '*') st.push(b * a);
            else st.push(b / a);
        }
    }
    return st.top();
}

int main() {
    string exp = "34+12-*";
    cout << calc(exp) << endl;
}
```

　

# 9.3 (括弧列的一致性判斷)

使用堆疊可以如下進行括弧列的一致性判斷。例如， `(()(())())(()())`的情況時，如下表所示。

　

-----

+ 起初，將堆疊保持為空的狀態
+ 從左到右檢查括弧列，
    + 如果是左括弧 `(`，將其push進堆疊
    + 如果是右括弧 `)`，
        + 如果堆疊是空的，則判斷為「不一致」
        + 如果堆疊非空，則pop出堆疊的頂部元素（此時彈出的 `(` 與手邊的 `)` 相對應）

完成以上處理時，如果堆疊是空的，則括弧列可判斷為「一致」，如果堆疊非空，則可判斷為「不一致」。

-----

 

　

| 括弧列           | 堆疊中的元素 |
| ------------------ | -------------- |
| `(`                | [ ( ]          |
| `((`               | [ (, ( ]       |
| `(()`              | [ ( ]          |
| `(()(`             | [ (, ( ]       |
| `(()((`            | [ (, (, ( ]    |
| `(()(()`           | [ (, ( ]       |
| `(()(())`          | [ ( ]          |
| `(()(())(`         | [ (, ( ]       |
| `(()(())()`        | [ ( ]          |
| `(()(())())`       | [ ]            |
| `(()(())())(`      | [ ( ]          |
| `(()(())())((`     | [ (, ( ]       |
| `(()(())())(()`    | [ ( ]          |
| `(()(())())(()(`   | [ (, ( ]       |
| `(()(())())(()()`  | [ ( ]          |
| `(()(())())(()())` | [ ]            |

　

具體的程式碼可以如下實作。計算複雜度為 O(N) 。

　


```cpp
#include <iostream>
#include <string>
#include <vector>
#include <algorithm>
#include <stack>
using namespace std;

bool check(const string &S) {
    stack<int> st; // 儲存左括弧 index 的堆疊
    vector<pair<int,int> > ps; // 表示對應的配對

    // 進行迴圈
    for (int i = 0; i < (int)S.size(); ++i) {
        if (S[i] == '(') st.push(i);
        else {
            if (st.empty()) {
                cout << "error" << endl;
                return false;
            }
            int t = st.top();
            st.pop();
            ps.push_back({t, i});
        }
    }

    // 如果堆疊不是空的，則左括號過多
    if (!st.empty()) {
        cout << "too many (" << endl;
        return false;
    }

    // 輸出整合結果
    sort(ps.begin(), ps.end());
    for (int i = 0; i < (int)ps.size(); ++i) {
        if (i) cout << ", ";
        cout << "(" << ps[i].first << ", " << ps[i].second << ")";
    }
    cout << endl;
    return true;
}

int main() {
    check("((()())())"); // (0, 9) (1, 6), (2, 3), (4, 5), (7, 8)
    check("())"); // error
    check("(()"); // too many (
}
```

